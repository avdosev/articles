<div xmlns="http://www.w3.org/1999/xhtml">Этим летом на GDC старший VFX-артист Remedy Йоханнес Рихтер рассказал о том,
    как реализовано процедурное разрушение в последней игре студии — мистическом экшене Control.<br />
    <br />
    В своей лекции он уделил внимание основному принципу построения многих внутриигровых эффектов, или принципу
    гранулярности. О том, как студия реализовала масштабную систему реалистичной разрушаемости, с какими ограничениями
    собственных ресурсов и производительности платформ столкнулась, какие оптимизации произвела и какие уроки из всего
    этого вынесла — далее в материале.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/7p/4e/fq/7p4efqk1lt4zakrjob-dgn3znqi.gif" /><br />
    <a name="habracut"></a><br />
    Итак, сначала о вызовах, с которыми столкнулась студия.<br />
    <br />
    Действие игры происходит внутри здания правительственного агентства в бруталистском стиле, имеющего некоторые
    сверхъестественные черты — например, движущиеся стены. <br />
    <br />
    Устройство штаба должно было выглядеть правдоподобно, ведь это правительственное агентство, где работают тысячи
    сотрудников службы, выполняющие рутинные поручения. Столы, телефоны, кружки, МФУ — все это обычные для офисного
    работника атрибуты, которые ожидаешь увидеть на рабочем месте, и своим присутствием они помогают качественно
    рассказать историю этого самого места. Брутализм подразумевает тонны бетона, но и не только: здесь у нас и дерево, и
    стекло, создающие наиболее подходящий облик для здания спецслужбы.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/-z/ho/yo/-zhoyonpug7m2uvwweqfuw0xie4.jpeg"
        data-src="https://habrastorage.org/webt/-z/ho/yo/-zhoyonpug7m2uvwweqfuw0xie4.jpeg" data-blurred="true" /><br />
    <br />
    Когда речь заходит о разрушении, в первую очередь стоит задуматься о тактильности. Перед командой разработчиков
    стояла задача организовать богатое интерактивное окружение, сразу создающее ощущение возможности взаимодействия
    практически с чем угодно в его пределах.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/lr/kc/rg/lrkcrgzvah8sxjyul1wlmjw0su8.jpeg"
        data-src="https://habrastorage.org/webt/lr/kc/rg/lrkcrgzvah8sxjyul1wlmjw0su8.jpeg" data-blurred="true" /><br />
    <br />
    Очевидно, студия при работе столкнулась и с определенными ограничениями. Взаимодействия с предметами должны были
    выглядеть и ощущаться реалистично. Игрок должен обладать определенной свободой действия касательно разрушений, но не
    безграничной, поскольку возможности игры упираются в конечные производительность платформ, память и требования к
    искусственному интеллекту. При этом команда, на которую была возложена задача реализовать разрушаемое окружение,
    оказалась совсем небольшой, что тоже необходимо было учитывать в работе.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/ib/u6/94/ibu694fqzr1iuv3rm1eaa2otqhg.jpeg"
        data-src="https://habrastorage.org/webt/ib/u6/94/ibu694fqzr1iuv3rm1eaa2otqhg.jpeg" data-blurred="true" /> <br />
    <br />
    Итак, в основе внутриигровой разрушаемости лежит принцип гранулярности. Он же заложен и в основу многих спецэффектов
    в кинематографе. Смысл его заключается в том, что природа не определяется количественно. Это непрерывное полотно,
    создаваемое из широкого спектра объектов — от больших до маленьких, от масштабных твердых тел до пыли и дыма. Если
    что-то их этого не отражать на экране, цельной картины не сложится.<br />
    <br />
    В игровом движке этот принцип можно реализовать в виде трех различных уровней детализации. Объекты на них
    представлены в виде твердых тел (Rigid Bodies), их деталей, частей пропсов, самих пропсов и окружения. Последнее в
    данном случае представляет собой своеобразную статическую сетку, с которой могут столкнуться интерактивные объекты.
    Частицы сетки, иерархия твердых тел и декали материалов придают объектам большую детализацию на определенных слоях.
    Так, от цельных объектов мы переходим к их фрагментам и затем к обломкам. Последний слой — непосредственно частицы.
    Спрайты частиц, частицы от тлеющих углей, песок и прочее — все это играет большую роль при заполнении подобных
    градиентов.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/cu/3k/td/cu3ktdnsgcz8ax1njp0ggwowmve.jpeg"
        data-src="https://habrastorage.org/webt/cu/3k/td/cu3ktdnsgcz8ax1njp0ggwowmve.jpeg" data-blurred="true" /><br />
    <br />
    На скриншоте выше показано статичное окружение. Выглядит довольно пусто, хотя некоторая детализация здесь есть:
    например, на заднем плане можно заметить перила для лестницы.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/8a/pj/u_/8apju_ycjka3rwb3ap-vi3khwus.jpeg"
        data-src="https://habrastorage.org/webt/8a/pj/u_/8apju_ycjka3rwb3ap-vi3khwus.jpeg" data-blurred="true" /><br />
    <br />
    Удивительно, как меняется восприятие, когда мы начинаем заполнять пространство объектами, с которыми можно
    непосредственно взаимодействовать. <br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/rr/vx/wj/rrvxwj_ikwqjh7njbmsofca89ga.jpeg"
        data-src="https://habrastorage.org/webt/rr/vx/wj/rrvxwj_ikwqjh7njbmsofca89ga.jpeg" data-blurred="true" /><br />
    <br />
    Что касается рабочего процесса в Remedy, на самом деле он довольно тривиален. Художники по окружению предоставляют
    модули геометрии уровня и пропсы для сборки, после чего VFX-отдел производит настройку ригов и кинематографической
    анимации разрушения. Наконец, после этого результат отправляется в собственный движок Remedy — Northlight.<br />
    <br />
    Было необходимо определиться с подходом, как все будет работать, и команда остановилась на процедурном. <br />
    <br />
    Что это значит? <br />
    <br />
    Процедурный подход — это основанная на правилах обработка и интерпретация данных.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/du/cn/kp/ducnkpukuijdfl2si2m-l7dbshe.jpeg"
        data-src="https://habrastorage.org/webt/du/cn/kp/ducnkpukuijdfl2si2m-l7dbshe.jpeg" data-blurred="true" /><br />
    <br />
    Информация об игровом мире представлена моделями, содержащими метаданные о материалах. Так, можно задать, например,
    что сиденья скамьи сделаны из ткани, основание — из бетона, растения — собственно, растения. Определив материалы,
    можно сформулировать конечный набор правил для каждого из них, определяющий реакции на все действия, которые могут
    производиться в игре. Например, чтобы при стрельбе от растений отлетали кусочки листьев, бетон разбивался на
    осколки, а металлическая труба деформировалась, и из нее прорывалась вода. Затем все данные перенаправляются в
    движок, и он уже на каждое взаимодействие реагирует надлежащим образом.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/8w/7h/rs/8w7hrsfslrioq_pucwtfegxouqe.jpeg"
        data-src="https://habrastorage.org/webt/8w/7h/rs/8w7hrsfslrioq_pucwtfegxouqe.jpeg" data-blurred="true" /><br />
    <br />
    Так почему именно процедурное разрушение?<br />
    <br />
    Потому что был необходим быстрый и последовательный оборот действий, предсказуемое поведение в рамках четко
    определенных условий. В игре задействованы сотни ассетов. На изображении выше вы можете увидеть всевозможные блоки,
    из которых состоят комнаты, стены, колонны, лестницы, перила и многое другое. Под ним — различные пропсы: столы,
    стулья, вазы, растения, компьютеры, телефоны. Для реализации разрушения такого разнообразия объектов выделена
    команда лишь из 1-3 человек. Поэтому было необходимо предопределить паттерны, по которым работает мир: если на
    объект воздействуют определенным образом, нужно, чтобы он ломался именно так, как это прописано для выбранного
    способа разрушения данного материала.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/et/mi/qm/etmiqmpcuekawavjlqxoonkyo9k.jpeg"
        data-src="https://habrastorage.org/webt/et/mi/qm/etmiqmpcuekawavjlqxoonkyo9k.jpeg" data-blurred="true" /><br />
    <br />
    Итак, необходимо было задать определенное поведение в зависимости от материала. Чтобы, когда вы стреляете бы по
    дереву, оно бы разлеталось на щепки. Или, если вы стреляете по стеклу, оно бы разбивалось на осколки. При этом
    частицы и декали тоже должны вести себя определенным образом в соответствии с тем, из чего сделан предмет.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/mu/ty/qj/mutyqjg4ja-shvg0gb6dsf5yi-i.jpeg"
        data-src="https://habrastorage.org/webt/mu/ty/qj/mutyqjg4ja-shvg0gb6dsf5yi-i.jpeg" data-blurred="true" /><br />
    <br />
    Для каждого материала существует своя геометрия разрушаемости, задаваемая различными уровнями. На примере мы видим
    кусок перил, в основе которого — бетон, затем — металлическую подпорку и, наконец, дерево. Слева направо показаны
    этапы, как они ломаются:<br />
    <br />
    <ul>
        <li>Уровень А показывает разлом бетона. Декалей здесь нет, поскольку трещин еще немного. Видно, что подпорка
            немного погнута.</li>
        <li>Уровень B. Металла уже нет, но остаются еще больше поломанные бетон и дерево.</li>
        <li>Уровень C опционален: когда он есть, представляет собой еще больше разломов.</li>
    </ul><br />
    Теперь представим, что мы ударяем по определенному углу объекта — тогда он не должен разбиться полностью, только его
    часть.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/ep/gs/v9/epgsv9o9xyw9qns-eokdafxymom.jpeg"
        data-src="https://habrastorage.org/webt/ep/gs/v9/epgsv9o9xyw9qns-eokdafxymom.jpeg" data-blurred="true" /><br />
    <br />
    Итак, в Control существуют твердые тела, представляющие собой цельный объект. Но еще есть детали, соединенные
    связями. Это те же твердые тела, которые может разделить так называемое составное столкновение.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/4o/un/ox/4ounoxja2in-fu1i0dyhzfxglpk.jpeg"
        data-src="https://habrastorage.org/webt/4o/un/ox/4ounoxja2in-fu1i0dyhzfxglpk.jpeg" data-blurred="true" /><br />
    <br />
    Детали создаются во время инициализации, имеют общий коллайдер и движутся как одно целое до тех пор, пока не
    сломаются. Они соединены друг с другом теми поверхностями, которыми соприкасаются между собой.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/bs/wv/jq/bswvjq8eptk5r731ujcrdwp_iz0.jpeg"
        data-src="https://habrastorage.org/webt/bs/wv/jq/bswvjq8eptk5r731ujcrdwp_iz0.jpeg" data-blurred="true" /><br />
    <br />
    Поговорим о соединениях. Они создаются в геометрической иерархии на основе метаданных. Твердые тела связываются друг
    с другом неким шарниром — например, в случае с дверью или выдвижным ящиком. Их можно динамически разрушить,
    опять-таки, за счет силы импульса.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/ln/uj/xb/lnujxbwcn97-89vdc53vxswyulq.jpeg"
        data-src="https://habrastorage.org/webt/ln/uj/xb/lnujxbwcn97-89vdc53vxswyulq.jpeg" data-blurred="true" /><br />
    <br />
    Для соединений существует особая физика разрушения. Они не ломаются вместе с объектом — то есть, если проделать дыру
    в двери, дверь все еще останется целым объектом, удерживающимся на счет внутренних соединений. Таким образом, если
    разбить родительский блок RB1, дверь не сорвется с петель: к проему все еще будет прикреплен ее кусок, не затронутый
    ударом. И дверь с дырой посередине все еще сможет закрываться и открываться, как и положено. Таким образом
    разработчики хотели избежать ситуаций, когда объекты ломаются полностью вне зависимости от того, куда и какой силы
    пришелся удар, как это бывает в некоторых играх.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/w_/pb/wf/w_pbwfzuly2oul7mpqg4dvr3eo8.jpeg"
        data-src="https://habrastorage.org/webt/w_/pb/wf/w_pbwfzuly2oul7mpqg4dvr3eo8.jpeg" data-blurred="true" /><br />
    <br />
    В процессе моделирования в собственном движке Northlight выполняется логика разрушения и определяется, какие события
    и частицы на нее реагируют. Затем физический движок NVIDIA моделирует твердые тела и старается вписать их в
    существующие для игры ограничения.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/sd/0c/fw/sd0cfwsojofvvbajuhs31eh-bvm.jpeg"
        data-src="https://habrastorage.org/webt/sd/0c/fw/sd0cfwsojofvvbajuhs31eh-bvm.jpeg" data-blurred="true" /><br />
    <br />
    Само разрушение реализуется следующим образом. У нас есть некоторая входная геометрия. Иногда необходимо
    предварительно подготовить модель, задать геометрию склеивания и определить, в каких случаях какие детали могут
    сломаться. Затем модели отправляются в Houdini и обрабатываются там. Разрушение в Houdini — довольно масштабная
    установка формата HDA, выполняющая реакции на основе материалов и записывающая данные в память. Иногда приходилось
    вручную исправлять и устанавливать некоторые метаданные физики, чтобы убедиться, что настройки верны, особенно когда
    дело касалось соединений. Затем все данные передаются в движок, где используются для создания игрового мира.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/tx/_j/d-/tx_jd-jsvrolfpsxi9zzgm6azuy.gif" /><br />
    <br />
    Инструмент разрушения в Houdini выглядит примерно так. Допустим, у нас есть входные данные в виде бетонного блока.
    Необходимо определить, какие области могут сломаться, и задать материал. В данном случае блок будет выполнять
    разрушение по правилам, заданным для бетона, управлять им и создавать различные иерархии с точки зрения геометрии
    рендеринга и столкновений. Затем необходимо убедиться, что моделирование производится в рамках имеющегося бюджета и
    заданного стиля. После этого можно экспортировать модель в движок.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/hv/_1/eb/hv_1ebqpognc7q72mfspmdnnuoo.jpeg"
        data-src="https://habrastorage.org/webt/hv/_1/eb/hv_1ebqpognc7q72mfspmdnnuoo.jpeg" data-blurred="true" /><br />
    <br />
    В движке это выглядит так. У вас есть некая иерархия, несущая информацию о слоях A, B, C и т. д. Сюда входит
    название материала, статичный ли объект или нет, данные о соединениях, их типах и прочем. Иерархия представлена
    уровнями, а физические свойства различаются в зависимости от наименования материала. При правильном задании имени
    физика обрабатывается движком. О проблеме имен мы еще поговорим позже.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/-k/yr/ww/-kyrwwpx8drsqxq2qyefxoczpl8.gif" /><br />
    <br />
    Выше показан сценарий симуляции твердого тела. Джесси стреляет в окружающие ее предметы, и они взрываются, тем самым
    реализуя физику разрушения.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/ji/2h/xp/ji2hxpyynebc7jkqqyyckewwrb0.jpeg"
        data-src="https://habrastorage.org/webt/ji/2h/xp/ji2hxpyynebc7jkqqyyckewwrb0.jpeg" data-blurred="true" /><br />
    <br />
    Поскольку разрушаемое окружение — вещь ресурсоемкая, а консоли и ПК имеют свои пределы производительности, перед
    командой стояла задача оптимизации системы, чтобы она не слишком нагружала устройства.<br />
    <br />
    Поскольку нужно было вписываться в определенный бюджет по производительности, был установлен лимит в 200 активных
    твердых тел на экране — таким образом, предметы за его пределами исчезали вовсе. <br />
    <br />
    В случае событий, задействующих множество быстро движущихся объектов, имеет место задержка столкновений для того,
    чтобы система успела произвести все вычисления.<br />
    <br />
    Также был реализован режим сна у неиспользуемых предметов. Допустим, если бетонный блок упадет на пол, никто не
    ожидает, что он начнет прыгать, подобно мячику, — так что довольно быстро он может «заснуть». Это относится ко
    многим предметам в игре. По той же причине их можно складывать друг на друга, и они точно так же будут лежать
    неподвижно.<br />
    <br />
    Кроме того, пробелы между предметами были заполнены частицами. Таким образом, при разрушении объекта вокруг него
    образуется пыль или щепки.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/p8/mo/xw/p8moxwdwmrjc9_7ti-jzpjkyyxi.jpeg"
        data-src="https://habrastorage.org/webt/p8/mo/xw/p8moxwdwmrjc9_7ti-jzpjkyyxi.jpeg" data-blurred="true" /><br />
    <br />
    В игре все системно и событийно. Существуют следующие события, связанные с частицами:<br />
    <br />
    <ul>
        <li>удар пули, имеющий различный исход в зависимости от материала;</li>
        <li>разрыв связи между двумя деталями; в данном случае происходит слом, высвобождающий частицы;</li>
        <li>полное разрушение объекта, приводящее к его распаду на частицы.</li>
    </ul><br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/od/sa/0v/odsa0vz3jgm5gcxh1uwxepgxdpo.gif" /><br />
    <br />
    Выше показан процесс редактирования частиц. Прямо в игре вы можете разместить некую систему частиц и затем изменить
    ее. В данном случае просто меняется частота формирования искр. Что интересно, изменить ее можно буквально в реальном
    времени и тут же получить мгновенный отклик, а затем проиграть снова и посмотреть, как срабатывает эффект.
    Реализованный таким образом быстрый цикл итераций позволяет отшлифовать подобные вещи, пока они не начнут
    отображаться правильно.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/z2/im/pg/z2impg-lp4_c44gvchog1osopns.gif" /><br />
    <br />
    Еще одна особенность частиц — стандартное моделирование. Время от времени команде приходилось использовать поля
    расстояний со знаком (signed distance fields, SDF). Благодаря этому удалось добиться, чтобы объекты не проваливались
    сквозь пол, что выглядело бы крайне странно.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/zv/rp/pc/zvrppctewqsijgeowbebkr-m5qg.gif" /><br />
    <br />
    На примере выше разрушаемый предмет представляет собой симбиоз частиц и твердого тела. Именно это мы и видим. От
    взрыва в воздухе появляется пыль за счет дополнительных слоев частиц, заполняющих недостающие пробелы в градиенте
    гранулярности.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/ux/he/08/uxhe08otqlrgzrkqev4obpnqaoe.jpeg"
        data-src="https://habrastorage.org/webt/ux/he/08/uxhe08otqlrgzrkqev4obpnqaoe.jpeg" data-blurred="true" /><br />
    <br />
    И последнее — декали материалов, коих в игре много и порождаются они динамически. По сути, это просто текстуры,
    которые накладываются поверх объектов для создания видимости разрушения.<br />
    <br />
    Если что-то ломается, на предмете появится декаль с изображением трещин. Обычно они создаются в Houdini или его
    аналогах. В Control выбор нужной декали происходит динамически на основе материала. Это помогло также задействовать
    довольно большую часть статической геометрии. Как было показано в начале, вокруг нас всегда много статических
    объектов, которые тоже могут подвергаться некоему воздействию, которое необходимо учитывать.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/lg/0j/ls/lg0jlseoi6dpmuncnaqye0kw9oy.gif" /><br />
    <br />
    Вот как это выглядит. Если вы разобьете пол, сам полигон останется тем же, но с появлением декалей его внешний вид
    может сильно измениться. Стоит заметить, что в использовании они довольно экономны и эффектны.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/wf/rm/ps/wfrmps161jxiqs2wmloyjzmy_u8.gif" /><br />
    <br />
    Итак, нас есть частицы, твердые тела и декали. В этом примере пришлось пойти на кое-какие ухищрения, потому что
    простой инструмент взрыва не породил бы столько декалей. Теперь Джесси «бросает» некий объект, способный оставить
    вмятину в полу. Пол при этом остается статичным полигоном, но благодаря декалям на нем остаются следы от
    удара.<br />
    <br />
    <img src="/img/image-loader.svg"
        data-src="https://habrastorage.org/webt/un/-e/0r/un-e0rq5hzfq1k0eio1qadzjizc.gif" /><br />
    <br />
    Еще затронем тему кастомных пропсов. Существует множество внутриигровых предметов, которые можно разбросать —
    огнетушители, компьютеры, лампы и тому подобное, — которые нельзя полностью процедурно сгенерировать. Эффекты для
    каждого из них художникам по окружению все же приходилось задавать вручную. Впрочем, от их наличия внутриигровой мир
    выглядит только богаче и разнообразнее.<br />
    <br />
    Итак, какие уроки извлекла студия, работая над Control?<br />
    <br />
    Здесь стоит затронуть следующие вещи:<br />
    <br />
    <ul>
        <li>качество геометрии входных данных;</li>
        <li>согласование наименований материалов;</li>
        <li>инструменты монолитного разрушения;</li>
        <li>мониторинг производительности.</li>
    </ul><br />
    <img src="https://habrastorage.org/r/w780q1/webt/sb/wt/k2/sbwtk2rnbj079bksw5qlwpa84eu.jpeg"
        data-src="https://habrastorage.org/webt/sb/wt/k2/sbwtk2rnbj079bksw5qlwpa84eu.jpeg" data-blurred="true" /><br />
    <br />
    Первое — это качество геометрии. Несогласованная входящая геометрия может возникать при неправильном масштабировании
    и ориентации, но также и из-за неправильного назначения материалов. Иногда качество сетки может оказаться слишком
    низким, и это тоже будет пагубно сказываться на результате. Еще случается, что, когда вы ломаете объект, то
    понимаете, что внутри него ничего нет, и это неправильно. Чтобы избежать таких проблем, необходимо улучшить входящие
    данные, стандартизировать весь пайплайн геометрии так, чтобы при экспорте система предупреждала, если что-то не
    соответствует критериям и требует исправления. Это помогло бы избежать постоянной петли обратной связи между
    различными отделами в поисках того, когда именно возникли проблемы. <br />
    <br />
    Кроме того, неплохо бы иметь встроенные инструменты, чтобы можно было смоделировать объект и сразу увидеть, как он
    будет выглядеть при разрушении. Очевидно, это порождает проблему создания большего количества инструментов с более
    удобными интерфейсами, но стоит того, чтобы этим озаботиться.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/zy/sh/s0/zyshs0plfuaozeb-sga8zlb2rpg.jpeg"
        data-src="https://habrastorage.org/webt/zy/sh/s0/zyshs0plfuaozeb-sga8zlb2rpg.jpeg" data-blurred="true" /><br />
    <br />
    Мы привыкли давать названия различным вещам. Но проблема в том, что эти названия могут быть некорректными. Например,
    в Control существует 17 различных вариантов обозначения материала «бетон», и в этом нельзя никого винить, ведь
    всегда имеет место человеческий фактор. Совет Рихтера — вообще отказаться от стандарта имен. Лучше просто завести
    единый API метаданных. Таким образом, независимо от того, какой инструмент художники используют для создания
    пропсов, можно экспортировать данные в движок прямиком оттуда без каких-либо промежуточных этапов.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/pr/ny/ep/prnyepm0uiq12-60sshmyzhmcfc.jpeg"
        data-src="https://habrastorage.org/webt/pr/ny/ep/prnyepm0uiq12-60sshmyzhmcfc.jpeg" data-blurred="true" /><br />
    <br />
    Следующий урок по большей части специфический для Houdini. Суть в том, что зачастую, начиная работу над чем-то, вы
    это еще множество раз его переделываете в процессе, совершаете какие-то надстройки, и необходимо убедиться, что даже
    спустя два года работы вы сможете открыть исходный файл даже несмотря на то, что рабочий инструмент мог уже
    поменяться 20 раз. Это означает, что вам понадобится некая стандартизация работы с HDA. Именно над этим сейчас
    работают в Remedy: над тем, чтобы все было правильно распределено, и вы никогда не потеряли какую-либо версию
    инструмента и всегда имели возможность повторить то, что делали в прошлом. <br />
    <br />
    Здесь важно заметить, что, создавая автоматизированные инструменты, вы по факту используете то же программное
    обеспечение, как если бы вы все делали вручную. И пока у них один и тот же бэкэнд, все должно быть полностью
    согласовано.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/7o/ey/zz/7oeyzzkrv-yyowkyqjrgocufjak.jpeg"
        data-src="https://habrastorage.org/webt/7o/ey/zz/7oeyzzkrv-yyowkyqjrgocufjak.jpeg" data-blurred="true" /><br />
    <br />
    Производительность и тестирование — одни из самых существенных аспектов разработки. <br />
    <br />
    Изначально в Remedy тесты не были автоматизированными. После добавления на уровень новых объектов его необходимо
    было пройти вручную, чтобы проверить, что все работает правильно. Но потом что-то менялось в движке, менялся бэкэнд,
    что-то оптимизировалось, и после этого требовалось повторное тестирование. Это довольно опасно, ведь что-то
    проверить вы непременно забудете. Словом, не лучший способ, приводящий к потенциальному накоплению багов.<br />
    <br />
    Второй аспект — тестирование производительности. Долгое время в Remedy не измеряли какие-либо существенные
    показатели вроде частоты кадров или времени вычисления. Таким образом, проблемы с производительностью довольно часто
    обнаруживались слишком поздно. <br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/lj/_g/v0/lj_gv0naz_epzp93umuheomzuve.jpeg"
        data-src="https://habrastorage.org/webt/lj/_g/v0/lj_gv0naz_epzp93umuheomzuve.jpeg" data-blurred="true" /><br />
    <br />
    Что можно здесь предпринять — это, в первую очередь, улучшить показатели производительности. Необходимо определить,
    увеличение каких параметров будет сказываться на игре лучше или хуже, чтобы опираться на это при оптимизации и
    определении бюджета, за который нельзя выходить.<br />
    <br />
    Помимо этого, вам поможет автоматизированное тестирование, в рамках которого также можно внести разнообразие в
    выходные данные для того, чтобы они нагляднее демонстрировали влияние изменений в движке.<br />
    <br />
    <img src="https://habrastorage.org/r/w780q1/webt/bn/4y/aq/bn4yaqvx_tl_z7eeb8-hkmkz1og.jpeg"
        data-src="https://habrastorage.org/webt/bn/4y/aq/bn4yaqvx_tl_z7eeb8-hkmkz1og.jpeg" data-blurred="true" /><br />
    <br />
    Также можно определить и принять меры против снижения производительности. Например, сделать так, чтобы во время
    крупномасштабных событий некоторые объекты миновали промежуточные уровни разрушения — скажем, от твердых тел
    переходя сразу к частицам.<br />
    <br />
    Еще одна мера — это зонирование площади в зависимости от ожидаемой нагрузки. В основе этой идеи лежит то, что мы
    можем сами определять, к какой области применить определенные контрмеры для того, чтобы не применять их ко всем
    ассетам на уровне, когда в этом нет необходимости. Например, если в скором времени к Джесси подоспеют враги с
    гранатами, очевидно, в локации будет слишком много разрушений, и на время их нападения можно ускорить процесс
    генерации разрушений.<br />
    <br />
    По итогу хочется отметить, что команда Remedy проделала монументальную работу, из которой можно почерпнуть множество
    идей в части реализации и оптимизации системы процедурного разрушения окружения.
</div>